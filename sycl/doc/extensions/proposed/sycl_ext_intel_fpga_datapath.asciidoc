= sycl_ext_intel_fpga_datapath

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes. This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation. All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification. All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.


This extension also depends on the following other SYCL extensions:

* link:../supported/sycl_ext_oneapi_accessor_properties.asciidoc[
  sycl_ext_oneapi_accessor_properties.asciidoc] as described in the <<Properties for fpga memory>> section below
* link:sycl_ext_intel_fpga_mem.asciidoc[sycl_ext_intel_fpga_mem.asciidoc] as described in the <<Restrictions on creating fpga_mem objects>> section below
* link:sycl_ext_oneapi_device_global.asciidoc[sycl_ext_oneapi_device_global.asciidoc] as described in the <<Restrictions on creating fpga_mem objects>> section below

== Status
Experimental

This is an experimental extension specification, intended to provide early
access to features and gather community feedback. Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Overview

[NOTE]
====
In this document, we use `fpga_datapath` to indicate the proposed `sycl::ext::intel::experimental::fpga_datapath`.
====

The purpose of this document is to clearly describe and specify `fpga_datapath` and 
related concepts, types, and mechanisms, and to give examples and context for their usage.

=== Motivation
`fpga_datapath` is a class template templated on type T, that represents an object of type T. It is a request to the compiler to implement that object, when present in FPGA device code, in the datapath, as opposed to an off-datapath memory.

=== Example
[source,c++]
----
struct MyClass {
  bool x;
};

using namespace sycl::ext::intel::experimental;

sycl::queue q;
q.single_task([=] {
  fpga_datapath<int[4]> fm1{1, 3, 5, 7};
  fpga_datapath<MyClass> fm2;
  fm2.get().x = fm1[0];
});
----

Above we see an example that declares `fpga_datapath` variables `fm1`, `fm2`, and accesses them. 
`fm1` creates an allocation on the device that is private to the kernel and contains an array of four `int`s that is initialized to {1, 3, 5, 7}. `fm2` creates an allocation on the device that is private to the kernel and contains an object of type `MyClass` that is default-initialized.

`fpga_datapath` has reference wrapper-like semantics, and is implicitly convertible to the wrapped type. Of note,
because {cpp} doesn't allow for overloading of the "dot operator", a `get()`
member of `fpga_datapath` allows a reference to be extracted, to which the usual
dot operator may be applied.

== Specification

`fpga_datapath` is a class template templated on type T, that represents an object of type T. It is a request to the compiler to implement that object, when present in FPGA device code, in the datapath, as opposed to an off-datapath memory.

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification. An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_FPGA_DATAPATH` to one of the values defined in the table
below. Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.


[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Representation of FPGA memory

[source,c++]
----
namespace sycl::ext::intel::experimental {
template <typename T, typename PropListT = sycl::ext::oneapi::properties<>>
class fpga_datapath {
  ...
----

`fpga_datapath` is a class template, parameterized by the type of the underlying
allocation _T_ which encodes the size of the allocation.

`fpga_datapath` initializes the underlying object `T` with the values passed into its constructor.

[NOTE]
====

`fpga_datapath` has similar semantics to a reference wrapper. An fpga_datapath templated on a type T can implicitly convert to T, thereby allowing it to be used in most places that an object of type T could be used. The dot operator
(`operator.`) cannot be overloaded, so a `get()` member is provided to allow a
reference to be extracted directly when needed.
====

=== FPGA Datapath Interface

The section below and the table following describe the constructors and member functions for `fpga_datapath`.

[source,c++]
----
namespace sycl::ext::intel::experimental {

  template <typename T>
  class fpga_datapath {
  public:
    template <typename... S> constexpr fpga_datapath(S... args);
    
    // Access the underlying data
    operator T &() noexcept;
    operator const T &() const noexcept;

    T &get() noexcept;
    const T &get() const noexcept;

    // Enable assignments from underlying type
    fpga_datapath &operator=(const T &) noexcept;

    // Note that there is no need for "fpga_datapath" to define member functions
    // for operators like "++", "[]", "->", comparison, etc. Instead, the type
    // "T" need only define these operators as non-member functions. Because
    // there is an implicit conversion from "fpga_datapath" to "T&", the operations
    // can be applied to objects of type "fpga_datapath<T>"
  };

} // namespace sycl::ext::intel::experimental
----

[frame="topbot",options="header"]
|===
|Functions |Description

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename ... S>
constexpr fpga_datapath(S ... args);
----
|
Constructs a `fpga_datapath` object, and implicit storage for `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
operator T&() noexcept;
operator const T&() const noexcept;
----
|
Implicit conversion to a reference to the underlying `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
T& get() noexcept;
const T& get() const noexcept;
----
|
Returns a reference to the underlying `T`.

|===

=== Restrictions on creating fpga_datapath objects

There are restrictions on how the application can create objects of type
`fpga_datapath`. Applications that violate these restrictions are ill-formed.

* The `fpga_datapath` variable can only have accesses from a single kernel. This happens when `device_global` is templated on a `fpga_datapath` type. 

* The `fpga_datapath` variable cannot be templated on a `fpga_mem` object, as this is a conflict of requirements on how the variable should be implemented, on or off the datapath. Diagnostic is required.
